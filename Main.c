<<<<<<< HEAD
#pragma config(Sensor, dgtl1,  encWheel,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encIntake,      sensorQuadEncoder)
#pragma config(Motor,  port1,           mIntake,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mFly1,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mFly2,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mFly3,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           mFly4,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mDrBr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mDrFr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mDrBl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mDrFl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mIntake2,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "MecDrive.c"
#include "FlyControl.c"
#include "Utils.c"
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#include "Vex_Competition_Includes.c"

fw_motors fly;
void pre_auton()
{
  bStopTasksBetweenModes = true;
	DriveBase dr;
	dr.fl = mDrFl; dr.fr = mDrFr; dr.bl = mDrBl;	dr.br = mDrBr;
	initMecDrive(dr);
	fly.f1 = mFly1; fly.f2 = mFly2; fly.f3 = mFly3; fly.f4 = mFly4;
	fly.enc = encWheel;
}

void driveIntake(int ticks){
	int dTicks = 0;
	int iTicks = SensorValue[ encIntake ];
		while(abs(dTicks) < abs(ticks)){
	//		writeDebugStreamLine("%f   %f",SensorValue[encIntake], dTicks);
			motor[ mIntake2 ] = ticks > 0 ? 127 : -127;
			motor[ mIntake ] = ticks > 0 ? 127 : -127;
			dTicks = SensorValue[encIntake] - iTicks;
			wait1Msec(20);
		}
		motor[ mIntake ] =  0 ;
}

task autonomous()
{
		initFlyWheel(fly);
		setFlyWheel(LONG_RPM, LONG_PRED);
		wait1Msec(3000);
		driveIntake(400);
		wait1Msec(3000);
		writeDebugStreamLine("%f",SensorValue[encIntake]);
		driveIntake(400);
		wait1Msec(3000);
		writeDebugStreamLine("%f",SensorValue[encIntake]);
		driveIntake(400);
		wait1Msec(3000);
		driveIntake(400);
}

task intakeControl(){
	long initTime = nSysTime;
	int outToggle = 1;
	while(true){
		if(vexRT[Btn5D] == 1){
			writeDebugStreamLine("Fire");
			motor[mIntake] = 127;
			motor[mIntake2] = 127;
			while(vexRT[Btn5D] == 1){
				wait1Msec(50);
			}
		}
		else if(vexRT[Btn5U] == 1){

			if(outToggle == 1){
				outToggle = 0;
			}
			else{
				outToggle = 1;
				motor[mIntake2] = 127;
			}
			while(vexRT[Btn5U] == 1)
			{
				wait1Msec(20);
			}
		}
		else if(vexRT[Btn6D] == 1){
			driveIntake(400);
		}
		else if(vexRT[Btn6U] == 1){
			driveIntake(-400);
		}
		else if(vexRT[Btn7U] == 1){
			motor[mIntake] = -127;
			motor[mIntake2] = -127;
		}
		else if(vexRT[Btn7L] == 1){
			driveIntake(400);
			wait1Msec(400);
			driveIntake(400);
		}
		else{
			motor[mIntake] = 0;
		//	writeDebugStreamLine("%f", outToggle);
			if(outToggle == 1){
				motor[mIntake2] = 127;
			}
			else{
				motor[mIntake2] = 0;
			}
		}
		while(vexRT[Btn7D] == 1){
			while(true){
				writeDebugStreamLine("Fire");
				driveIntake(400);
				//wait1Msec(200);
			}
		}
		wait1Msec(20);
	}
}


//calibrate
void calibrate(){
		coeff = 0;
		for(int i = 1; i<100; i++){
			coeff = 0.001 + 0.0002 * i;
			writeDebugStreamLine("Testing Coeff %f", coeff);
			setFlyWheel(LONG_RPM,LONG_PRED);
			long pTime = nSysTime;
			long nTime = nSysTime;
			while(abs(pTime - nSysTime) < 4000){
				if(abs(error) > 100){
				long sTime = nSysTime;
						while(abs(error) > 10 && (abs(pTime - nSysTime) < 4000)){
							wait1Msec(50);
						}
					writeDebugStreamLine("%f, coeff %f  %f SETTLE TIME %f",error, coeff, Y, nSysTime - sTime);
				}
			}
			setFlyWheel(0,0);
			while(abs(error) > 10){
				//writeDebugStreamLine("zeroing");
				wait1Msec(500);
			}
		}
	}


task usercontrol()
{
	initFlyWheel(fly);
	startTask(intakeControl, 3);
	while(true)
	{
	//	_mecDrive();

	writeDebugStreamLine("%f, coeff %f  %f SETTLE TIME %f",error, coeff, Y, nSysTime);

	/**	if(vexRT[Btn7D] == 1){
			coeff = coeff + 0.0005;
			writeDebugStreamLine("%f",coeff);
			while(vexRT[Btn7D] == 1){
				wait1Msec(20);
			}
		}	 **/
	if(abs(error) > 100){
			long sTime = nSysTime;
			while(abs(error) > 10){
				wait1Msec(50);
			}
			writeDebugStreamLine("%f, coeff %f  %f SETTLE TIME %f",error, coeff, Y, nSysTime - sTime);
		}
	//	writeDebugStreamLine("%f, %f  %f",error, nAvgBatteryLevel, Y);
	//writeDebugStreamLine("curr %f, set %f", FwCalculateSpeed(), _setRPM);
		wait1Msec(100);
	}
}
=======
#pragma config(Motor,  port1,           mIntake,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mFly1,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mFly2,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mFly3,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           mFly4,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mDrBr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mDrFr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mDrBl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mDrFl,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define JOYSTICK_DEADZONE  5
//2-5 flyhweels, turbo MC
//port 1 intake
//port 6 7 wheels left 8 9 wheels right
//#include "FlyControl.c"
//#include "MecDrive.c"
//#include "Vex_Competition_Includes.c"


// void pre_autonomous()
// {
// //Place pre-autonomous code here
// }
// task autonomous()
// {
// 	AutonomousCodePlaceholderForTesting();
// }
//task usercontrol()



void mecDrive(){
	float x;
	float y;
	float speed;
	float turnSpeed;
	if(abs(vexRT[Ch1]) > JOYSTICK_DEADZONE){
		x = vexRT[Ch1];
	}
	if(abs(vexRT[Ch2]) > JOYSTICK_DEADZONE){
		y = vexRT[Ch2];
	}
//	if(abs(vexRT[Ch3]) > JOYSTICK_DEADZONE){
	 	speed = vexRT[Ch3]/127;
//	}
//	if(abs(vexRT[Ch4]) > JOYSTICK_DEADZONE){
		turnSpeed = vexRT[Ch4]/127;
//	}

	//float heading = atan(y/x);


	motor[mDrFr] = vexRT[Ch2] - vexRT[Ch4] - vexRT[Ch1];
	motor[mDrBr] = vexRT[Ch2] - vexRT[Ch4] + vexRT[Ch1];
	motor[mDrFl] = vexRT[Ch2] + vexRT[Ch4] + vexRT[Ch1];
	motor[mDrBl] = vexRT[Ch2] + vexRT[Ch4] - vexRT[Ch1];



}


void _updateFlyWheel(int power){
	motor[mFly1] = power;
	motor[mFly2] = power;
	motor[mFly3] = power;
	motor[mFly4] = power;
}

task FlyWheelControl(){
	while(true){
		if(vexRT[Btn5U]){
			_updateFlyWheel(80);
		}
		if(vexRT[Btn7D]){
			_updateFlyWheel(0);
		}
		if(vexRT[Btn6D]){
			_updateFlyWheel(30);
		}
		if(vexRT[Btn6U]){
			_updateFlyWheel(60);
		}

		wait1Msec(20);
	}
}

task main()
{
/**	DriveBase dr;
	dr.fl = mDrFl;
	dr.fr = mDrFr;
	dr.bl = mDrBl;
	dr.br = mDrBr;
	initMecDrive(&dr);**/
//	fw_motors fly;
	//fly.m[0] = mFly1;
	//fly.m[1] = mFly2;
	//fly.m[2] = mFly3;
	//fly.m[3] = mFly4;
	//initFlyWheel(fly);
	startTask(FlyWheelControl);
	bool toggle = false
	while(true)
	{
		if(vexRT[Btn5D] == 1){
			motor[mIntake] = 90;
		}

		else if(vexRT[Btn8D] == 1){
			motor[mIntake] = -127;
		}
		else{
			motor[mIntake] = 0;
		}
		mecDrive();
		delay(20);
	}

}
>>>>>>> b5e3c73c6bd360a3b94b865e28670ac787d211c8
