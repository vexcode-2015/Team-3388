
#pragma config(Sensor, dgtl1,  encWheel,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encIntake,      sensorQuadEncoder)
#pragma config(Sensor, in1,    gyroDrive,           sensorGyro)
#pragma config(Motor,  port1,           mIntake,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mFly1,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mFly2,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mFly3,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           mFly4,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mDrBr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mDrFr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mDrBl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mDrFl,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mIntake2,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "MecDrive.c"
#include "FlyControl.c"
#include "Utils.c"
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#include "Vex_Competition_Includes.c"

fw_motors fly;
int autoNum = 0;
void pre_auton()
{
	printBatteryToLCD();
	bStopTasksBetweenModes = false;
	DriveBase dr;
	dr.fl = mDrFl; dr.fr = mDrFr; dr.bl = mDrBl;	dr.br = mDrBr;
	dr.gyro = gyroDrive;
	initMecDrive(dr);
	printCalibratingGyro();
	enableGyro();
	fly.f1 = mFly1; fly.f2 = mFly2; fly.f3 = mFly3; fly.f4 = mFly4;
	fly.enc = encWheel;
	autoNum = readAutoNum();
}

void driveIntake(int ticks){
	int dTicks = 0;
	int iTicks = SensorValue[ encIntake ];
	while(abs(dTicks) < abs(ticks)){
	//	writeDebugStreamLine("%f   %f",SensorValue[encIntake], dTicks);
		motor[ mIntake2 ] = ticks > 0 ? 127 : -127;
		motor[ mIntake ] = ticks > 0 ? 127 : -127;
		dTicks = SensorValue[encIntake] - iTicks;
		wait1Msec(20);
	}
	motor[ mIntake ] =  0 ;
}

task autonomous()
{
	GyroResetAngle();
	initFlyWheel(fly);
	setFlyWheel(LONG_RPM, LONG_PRED);
	wait1Msec(3000);
	driveIntake(400);
	wait1Msec(3000);
	writeDebugStreamLine("%f",SensorValue[encIntake]);
	driveIntake(400);
	wait1Msec(3000);
	writeDebugStreamLine("%f",SensorValue[encIntake]);
	driveIntake(400);
	wait1Msec(3000);
	driveIntake(400);
	switch(autoNum){
		case 0:{
			break;
		}
		case 1:{
			break;
		}
		case 2:{
			break;
		}
	}
}

task intakeControl(){
	long initTime = nSysTime;
	int outToggle = 1;
	while(true){
		if(vexRT[Btn5D] == 1){
			writeDebugStreamLine("Fire");
			motor[mIntake] = 127;
			motor[mIntake2] = 127;
			while(vexRT[Btn5D] == 1){
				wait1Msec(50);
			}
		}
		else if(vexRT[Btn5U] == 1){

			if(outToggle == 1){
				outToggle = 0;
			}
			else{
				outToggle = 1;
				motor[mIntake2] = 127;
			}
			while(vexRT[Btn5U] == 1)
			{
				wait1Msec(20);
			}
		}
		else if(vexRT[Btn6D] == 1){
			driveIntake(400);
		}
		else if(vexRT[Btn6U] == 1){
			driveIntake(-400);
		}
		else if(vexRT[Btn7U] == 1){
			motor[mIntake] = -127;
			motor[mIntake2] = -127;
		}
		else if(vexRT[Btn7L] == 1){
			driveIntake(400);
			wait1Msec(400);
			driveIntake(400);
		}
		else{
			motor[mIntake] = 0;
		//	writeDebugStreamLine("%f", outToggle);
			if(outToggle == 1){
				motor[mIntake2] = 127;
			}
			else{
				motor[mIntake2] = 0;
			}
		}
		while(vexRT[Btn7D] == 1){
			while(true){
				writeDebugStreamLine("Fire");
				driveIntake(400);
				//wait1Msec(200);
			}
		}
		wait1Msec(20);
	}
}


//calibrate
void calibrate(){
	coeff = 0;
	for(int i = 1; i<100; i++){
		coeff = 0.001 + 0.0002 * i;
		writeDebugStreamLine("Testing Coeff %f", coeff);
		setFlyWheel(LONG_RPM,LONG_PRED);
		long pTime = nSysTime;
		long nTime = nSysTime;
		while(abs(pTime - nSysTime) < 4000){
			if(abs(error) > 100){
				long sTime = nSysTime;
				while(abs(error) > 10 && (abs(pTime - nSysTime) < 4000)){
					wait1Msec(50);
				}
				writeDebugStreamLine("%f, coeff %f  %f SETTLE TIME %f",error, coeff, Y, nSysTime - sTime);
			}
		}
		setFlyWheel(0,0);
		while(abs(error) > 10){
				//writeDebugStreamLine("zeroing");
			wait1Msec(500);
		}
	}
}


void driveTesting(){
		if(vexRT[Btn7D] == 1){
			printDriveEncoders();
		}	 

		if(vexRT[Btn7L] == 1){
			zeroDriveEncoders();
		} 
}


task usercontrol()
{
	GyroResetAngle();
	initFlyWheel(fly);
	startTask(intakeControl, 3);
	while(true)
	{
		_mecDrive();
		//driveTesting();


		writeDebugStreamLine("%f, coeff %f  %f SETTLE TIME %f",error, coeff, Y, nSysTime);

		
		//	writeDebugStreamLine("%f, %f  %f",error, nAvgBatteryLevel, Y);
		//writeDebugStreamLine("curr %f, set %f", FwCalculateSpeed(), _setRPM);
		wait1Msec(100);
	}
}